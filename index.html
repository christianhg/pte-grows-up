<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PTE Grows Up — It's Time to Own the Editor</title>
<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }
  @media(prefers-color-scheme:light) { body { background:#fafaf5; } }
  @media(prefers-color-scheme:dark) { body { background:#0a0e14; } }
</style>
</head>
<body>
<div id="app" style="width:100%;height:100%"></div>
<script>
const artifact = {
  render(container, ctx) {
    // ===== PORTABLE TEXT CONTENT — draft-2 with factBox blocks + highlight annotations =====
    const PT = [
      { _type:'block', _key:'title', style:'h1', markDefs:[], children:[
        { _type:'span', _key:'title.0', text:"It\u2019s Time to Own the Editor", marks:[] }
      ]},
      { _type:'block', _key:'subtitle', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'subtitle.0', text:"Why PTE should internalize Slate \u2014 and why the timing is now", marks:['strong'] }
      ]},

      // --- Opening ---
      { _type:'block', _key:'p01', style:'normal', markDefs:[
        { _key:'lnk1', _type:'link', href:'https://github.com/ianstormtaylor/slate' }
      ], children:[
        { _type:'span', _key:'p01.0', text:"Slate", marks:['lnk1'] },
        { _type:'span', _key:'p01.1', text:" got us here. That\u2019s worth saying upfront, and meaning it.", marks:[] }
      ]},
      { _type:'block', _key:'p02', style:'normal', markDefs:[
        { _key:'lnk2', _type:'link', href:'https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable' }
      ], children:[
        { _type:'span', _key:'p02.0', text:"When PTE needed a foundation for rich text editing, Slate was the right call. It gave us battle-tested ", marks:[] },
        { _type:'span', _key:'p02.1', text:"contenteditable", marks:['code','lnk2'] },
        { _type:'span', _key:'p02.2', text:" handling, solid DOM reconciliation, and a real selection model \u2014 the kind of deep browser plumbing that takes years to get right. Slate handled the hard, unglamorous work of making text editing actually work across browsers, and PTE built Portable Text semantics on top of it.", marks:[] }
      ]},
      { _type:'block', _key:'p03', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p03.0', text:"That architecture served us well. But over the past few years, something has shifted. We haven\u2019t just been building ", marks:[] },
        { _type:'span', _key:'p03.1', text:"on", marks:['em'] },
        { _type:'span', _key:'p03.2', text:" Slate \u2014 we\u2019ve been building ", marks:[] },
        { _type:'span', _key:'p03.3', text:"around", marks:['em'] },
        { _type:'span', _key:'p03.4', text:" it. And the gap between what Slate provides and what PTE needs has grown wide enough that we\u2019re now maintaining two systems where we should have one.", marks:[] }
      ]},
      { _type:'block', _key:'p04', style:'normal', markDefs:[
        { _key:'hl1', _type:'highlight' }
      ], children:[
        { _type:'span', _key:'p04.0', text:"This isn\u2019t a story about Slate failing. It\u2019s a story about PTE succeeding \u2014 to the point where ", marks:[] },
        { _type:'span', _key:'p04.1', text:"the wrapper has outgrown the thing it wraps", marks:['hl1'] },
        { _type:'span', _key:'p04.2', text:".", marks:[] }
      ]},

      // === The numbers tell the story ===
      { _type:'block', _key:'h2a', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2a.0', text:"The numbers tell the story", marks:[] }
      ]},
      { _type:'block', _key:'p05', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p05.0', text:"Here\u2019s the fact that reframes everything: ", marks:[] },
        { _type:'span', _key:'p05.1', text:"PTE\u2019s translation layer \u2014 the code that bridges between Portable Text and Slate \u2014 is 493KB of TypeScript across 136 files. Slate itself is 328KB.", marks:['strong'] }
      ]},

      // factBox 1: wrapper ratio
      { _type:'factBox', _key:'fb1', number:'493KB \u2192 328KB', label:'PTE\u2019s translation layer is 1.5\u00d7 the size of Slate itself' },

      { _type:'block', _key:'p06', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p06.0', text:"We\u2019ve built a system 1.5 times the size of the framework it sits on top of. And that system exists for one reason: to translate between two data models on every single operation.", marks:[] }
      ]},
      { _type:'block', _key:'p07', style:'normal', markDefs:[
        { _key:'lnk3', _type:'link', href:'https://www.sanity.io/docs/presenting-block-text' }
      ], children:[
        { _type:'span', _key:'p07.0', text:"Portable Text", marks:['lnk3'] },
        { _type:'span', _key:'p07.1b', text:" has blocks with ", marks:[] },
        { _type:'span', _key:'p07.1', text:"_type", marks:['code'] },
        { _type:'span', _key:'p07.2', text:", ", marks:[] },
        { _type:'span', _key:'p07.3', text:"_key", marks:['code'] },
        { _type:'span', _key:'p07.4', text:", spans, marks, and annotations. Slate has a recursive tree of Elements and Text nodes with a completely different shape. PTE maintains ", marks:[] },
        { _type:'span', _key:'p07.5', text:"both representations simultaneously", marks:['em'] },
        { _type:'span', _key:'p07.6', text:" \u2014 Slate\u2019s tree in ", marks:[] },
        { _type:'span', _key:'p07.7', text:"editor.children", marks:['code'] },
        { _type:'span', _key:'p07.8', text:" and a PT-native mirror in ", marks:[] },
        { _type:'span', _key:'p07.9', text:"editor.value", marks:['code'] },
        { _type:'span', _key:'p07.10', text:" \u2014 kept in sync on every keystroke, every paste, every collaborative edit. That dual-model sync alone accounts for ", marks:[] },
        { _type:'span', _key:'p07.11', text:"76KB of dedicated code", marks:['strong'] },
        { _type:'span', _key:'p07.12', text:".", marks:[] }
      ]},

      // factBox 5: dual-model sync
      { _type:'factBox', _key:'fb5', number:'76KB', label:'of code dedicated solely to keeping two models of the same document in sync' },

      { _type:'block', _key:'p08', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p08.0', text:"And it\u2019s not just size. PTE uses roughly ", marks:[] },
        { _type:'span', _key:'p08.1', text:"22% of Slate\u2019s API", marks:['strong'] },
        { _type:'span', _key:'p08.2', text:". That means 78% of the framework we ship is dead weight \u2014 code we carry but never call. We override 18 Slate methods. We run 8 plugins in a carefully ordered chain. We maintain 6 XState actors alongside Slate\u2019s own state. We\u2019ve replaced Slate\u2019s history system, its transform pipeline, its event handling, and most of its editor methods.", marks:[] }
      ]},

      // factBox 2: API dead weight
      { _type:'factBox', _key:'fb2', number:'22%', label:'of Slate\u2019s API surface is actually used by PTE \u2014 78% is dead weight' },

      { _type:'block', _key:'p08b', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p08b.0', text:"The most telling example is the Behavior API \u2014 PTE\u2019s own event system. It\u2019s 150KB across 30 files. It intercepts 13 of Slate\u2019s editor methods \u2014 ", marks:[] },
        { _type:'span', _key:'p08b.1', text:"delete", marks:['code'] },
        { _type:'span', _key:'p08b.2', text:", ", marks:[] },
        { _type:'span', _key:'p08b.3', text:"deleteBackward", marks:['code'] },
        { _type:'span', _key:'p08b.4', text:", ", marks:[] },
        { _type:'span', _key:'p08b.5', text:"insertBreak", marks:['code'] },
        { _type:'span', _key:'p08b.6', text:", ", marks:[] },
        { _type:'span', _key:'p08b.7', text:"insertText", marks:['code'] },
        { _type:'span', _key:'p08b.8', text:", ", marks:[] },
        { _type:'span', _key:'p08b.9', text:"redo", marks:['code'] },
        { _type:'span', _key:'p08b.10', text:", ", marks:[] },
        { _type:'span', _key:'p08b.11', text:"select", marks:['code'] },
        { _type:'span', _key:'p08b.12', text:", and more \u2014 and re-routes every user action through PTE\u2019s own XState machines. We didn\u2019t extend Slate\u2019s event handling. ", marks:[] },
        { _type:'span', _key:'p08b.13', text:"We replaced it.", marks:['strong'] }
      ]},

      { _type:'block', _key:'p09', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p09.0', text:"What we actually use Slate for, at this point, is DOM reconciliation and input handling. Everything else \u2014 the event system, the state model, the schema enforcement, the render dispatch, the mutation pipeline \u2014 we\u2019ve already rebuilt.", marks:[] }
      ]},

      // === The cost isn't theoretical ===
      { _type:'block', _key:'h2b', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2b.0', text:"The cost isn\u2019t theoretical", marks:[] }
      ]},
      { _type:'block', _key:'p10', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p10.0', text:"You might look at this and think: okay, it\u2019s a big translation layer, but it works. Why change what works?", marks:[] }
      ]},
      { _type:'block', _key:'p11', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p11.0', text:"Because it doesn\u2019t just work. It works ", marks:[] },
        { _type:'span', _key:'p11.1', text:"and", marks:['em'] },
        { _type:'span', _key:'p11.2', text:" it breaks, in ways that are uniquely expensive to debug and fix.", marks:[] }
      ]},
      { _type:'block', _key:'p12', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p12.0', text:"In a recent six-week window, ", marks:[] },
        { _type:'span', _key:'p12.1', text:"six bugs traced directly to the translation layer", marks:['strong'] },
        { _type:'span', _key:'p12.2', text:". Not to PTE logic. Not to Slate logic. To the ", marks:[] },
        { _type:'span', _key:'p12.3', text:"boundary", marks:['em'] },
        { _type:'span', _key:'p12.4', text:" between them:", marks:[] }
      ]},

      // factBox 3: bugs
      { _type:'factBox', _key:'fb3', number:'6 bugs in 6 weeks', label:'traced directly to the translation layer \u2014 ~1 per week, ongoing' },

      { _type:'block', _key:'b1', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'b1.0', text:"\u2022 A field named ", marks:[] },
        { _type:'span', _key:'b1.1', text:"text", marks:['code'] },
        { _type:'span', _key:'b1.2', text:" on a block object caused the dual-model sync to misidentify nodes and silently drop updates.", marks:[] }
      ]},
      { _type:'block', _key:'b2', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'b2.0', text:"\u2022 The patch translation emitted operations that treated ", marks:[] },
        { _type:'span', _key:'b2.1', text:"null", marks:['code'] },
        { _type:'span', _key:'b2.2', text:" as \"present,\" causing insert failures for users.", marks:[] }
      ]},
      { _type:'block', _key:'b3', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'b3.0', text:"\u2022 Duplicate ", marks:[] },
        { _type:'span', _key:'b3.1', text:"_key", marks:['code'] },
        { _type:'span', _key:'b3.2', text:" values caused the wrong child to appear selected.", marks:[] }
      ]},

      // Elevated data loss callout
      { _type:'block', _key:'dataloss', style:'normal', markDefs:[
        { _key:'hl2', _type:'highlight' }
      ], children:[
        { _type:'span', _key:'dataloss.0', text:"And the worst one: ", marks:[] },
        { _type:'span', _key:'dataloss.1', text:"data loss in collaborative editing.", marks:['strong'] },
        { _type:'span', _key:'dataloss.2', text:" Two editors working on the same document. Editor A\u2019s deferred normalization patches \u2014 stale state from the dual-model sync \u2014 silently overwrote Editor B\u2019s live changes. Bold formatting, gone. No error, no warning. ", marks:[] },
        { _type:'span', _key:'dataloss.3', text:"Users lost work because two internal models briefly disagreed about the truth, and the wrong one won.", marks:['hl2'] }
      ]},

      { _type:'block', _key:'b5', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'b5.0', text:"\u2022 Two separate sync machine failures when block types or children changed during external sync.", marks:[] }
      ]},
      { _type:'block', _key:'p13', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p13.0', text:"Five of those six bugs would be ", marks:[] },
        { _type:'span', _key:'p13.1', text:"structurally impossible", marks:['em'] },
        { _type:'span', _key:'p13.2', text:" without the translation layer. They exist because we maintain two models and translate between them. That\u2019s roughly one translation-layer bug per week \u2014 an ongoing tax on every engineer who touches PTE.", marks:[] }
      ]},
      { _type:'block', _key:'p14', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p14.0', text:"And the debugging experience compounds the cost. A single typing bug could live in the MutationActor\u2019s debouncing, the patches plugin\u2019s operation translation, Slate\u2019s ", marks:[] },
        { _type:'span', _key:'p14.1', text:"insertText", marks:['code'] },
        { _type:'span', _key:'p14.2', text:" handling, or the interaction between any of them. Developers have to hold three systems in their heads simultaneously. The translation layer creates a combinatorial bug surface: 8 operation types \u00d7 2 sync directions \u00d7 depth branching \u00d7 type handling = roughly 96 code paths. Our single largest test file \u2014 50KB \u2014 exists solely to verify that the dual-model sync doesn\u2019t drift.", marks:[] }
      ]},
      { _type:'block', _key:'p15', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p15.0', text:"Every keystroke passes through ", marks:[] },
        { _type:'span', _key:'p15.1', text:"40\u201350 function calls", marks:['strong'] },
        { _type:'span', _key:'p15.2', text:" from translation overhead alone. Structural operations like Enter or Delete hit 100\u2013250 calls as each Slate operation passes through all 8 plugin layers. The ", marks:[] },
        { _type:'span', _key:'p15.3', text:"buildIndexMaps", marks:['code'] },
        { _type:'span', _key:'p15.4', text:" function runs on every structural operation with O(N) document-size scaling \u2014 it gets slower as documents grow.", marks:[] }
      ]},

      // factBox 4: keystroke overhead
      { _type:'factBox', _key:'fb4', number:'40\u201350', label:'extra function calls per keystroke from translation overhead alone' },

      { _type:'block', _key:'p16', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p16.0', text:"This isn\u2019t tech debt we can pay down incrementally. It\u2019s architectural friction that\u2019s baked into the boundary between two systems.", marks:[] }
      ]},

      // === Containers ===
      { _type:'block', _key:'h2c', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2c.0', text:"Containers are the forcing function", marks:[] }
      ]},
      { _type:'block', _key:'p17', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p17.0', text:"We could live with this friction indefinitely if PTE\u2019s needs were static. They\u2019re not.", marks:[] }
      ]},
      { _type:'block', _key:'p18', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p18.0', text:"Container support \u2014 tables, callouts, blockquotes with editable children \u2014 is the next major capability PTE needs. And containers multiply every friction point in the translation layer.", marks:[] }
      ]},
      { _type:'block', _key:'p19', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p19.0', text:"The patch translation file (", marks:[] },
        { _type:'span', _key:'p19.1', text:"operation-to-patches.ts", marks:['code'] },
        { _type:'span', _key:'p19.2', text:", 17KB) ", marks:[] },
        { _type:'span', _key:'p19.3', text:"hardcodes a maximum depth of 2", marks:['strong'] },
        { _type:'span', _key:'p19.4', text:". Every function explicitly checks ", marks:[] },
        { _type:'span', _key:'p19.5', text:"operation.path.length === 1", marks:['code'] },
        { _type:'span', _key:'p19.6', text:" (block-level) vs ", marks:[] },
        { _type:'span', _key:'p19.7', text:"=== 2", marks:['code'] },
        { _type:'span', _key:'p19.8', text:" (child-level). Containers need arbitrary depth. Every function in that file would need to be rewritten.", marks:[] }
      ]},
      { _type:'block', _key:'p20', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p20.0', text:"The render pipeline needs a new branch. Normalization rules double. The ", marks:[] },
        { _type:'span', _key:'p20.1', text:"isVoid", marks:['code'] },
        { _type:'span', _key:'p20.2', text:" override \u2014 today a simple boolean check \u2014 must become context-dependent. Selection conversion gets deeper. The 30KB block insertion file gets worse.", marks:[] }
      ]},
      { _type:'block', _key:'p21', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p21.0', text:"We could build containers on top of the current architecture. But we\u2019d be adding a third layer of complexity to a system that\u2019s already struggling under two. The translation layer doesn\u2019t just make containers harder \u2014 it makes them fragile in ways that will cost us for years.", marks:[] }
      ]},

      // === Error philosophy ===
      { _type:'block', _key:'h2d', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2d.0', text:"Slate\u2019s error philosophy doesn\u2019t match ours", marks:[] }
      ]},
      { _type:'block', _key:'p22', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p22.0', text:"There\u2019s a subtler issue worth naming. Slate\u2019s error handling philosophy is to ", marks:[] },
        { _type:'span', _key:'p22.1', text:"throw hard and throw often", marks:['strong'] },
        { _type:'span', _key:'p22.2', text:". Invalid states, unexpected node types, missing paths \u2014 Slate crashes by design, treating these as programmer errors that should surface loudly.", marks:[] }
      ]},
      { _type:'block', _key:'p23', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p23.0', text:"That\u2019s a reasonable philosophy for a framework. It\u2019s a terrible philosophy for a production CMS.", marks:[] }
      ]},
      { _type:'block', _key:'p24', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p24.0', text:"When Slate throws in production, users see garbled stack traces with internal paths and Slate-specific terminology. ", marks:[] },
        { _type:'span', _key:'p24.1', text:"Cannot find a descendant at path [0,2,1]", marks:['code'] },
        { _type:'span', _key:'p24.2', text:" means something to a Slate developer. It means nothing to someone editing content in Sanity Studio.", marks:[] }
      ]},
      { _type:'block', _key:'p25', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p25.0', text:"Owning the editor code lets us take a fundamentally different approach: ", marks:[] },
        { _type:'span', _key:'p25.1', text:"recover instead of crash", marks:['strong'] },
        { _type:'span', _key:'p25.2', text:". Detect invalid states and normalize them back to valid. Surface errors in terms of block keys, schema types, and field names \u2014 concepts PTE developers understand. Render a corrupted block as a fallback instead of crashing the entire editor. Set error boundaries at the PT level (per-block, per-container) rather than the Slate level (per-operation).", marks:[] }
      ]},
      { _type:'block', _key:'p26', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p26.0', text:"Every Slate crash in production is a broken editor in someone\u2019s CMS. We can do better.", marks:[] }
      ]},

      // === Maintenance reality ===
      { _type:'block', _key:'h2e', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2e.0', text:"The maintenance reality", marks:[] }
      ]},
      { _type:'block', _key:'p27', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p27.0', text:"One concern that comes up naturally: aren\u2019t we walking away from an active open-source project? Wouldn\u2019t we lose upstream improvements?", marks:[] }
      ]},
      { _type:'block', _key:'p28', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p28.0', text:"The honest answer is that Slate doesn\u2019t have an active steward. There\u2019s no one driving the project\u2019s architectural direction. The one person with merge access checks in occasionally but isn\u2019t actively involved in development. Changes come from downstream users fixing things they need fixed \u2014 drive-by contributions with no coordinated vision.", marks:[] }
      ]},
      { _type:'block', _key:'p29', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p29.0', text:"Recent changes have been bug fixes and browser compatibility patches: removing the immer dependency, Shadow DOM fixes for Android, composition event handling. These are real improvements, and we\u2019d want to cherry-pick them. But there\u2019s no stream of innovations to miss. The features PTE needs \u2014 container support, a PT-native data model, multi-callback rendering \u2014 are things Slate will never provide. They\u2019re specific to Portable Text.", marks:[] }
      ]},
      { _type:'block', _key:'p30', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p30.0', text:"We\u2019re not walking away from an active partnership. We\u2019re acknowledging that we\u2019ve been maintaining our own editor for a while now \u2014 we just haven\u2019t made it official.", marks:[] }
      ]},

      // === The plan ===
      { _type:'block', _key:'h2f', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2f.0', text:"The plan: vendor first, then unify", marks:[] }
      ]},
      { _type:'block', _key:'p31', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p31.0', text:"This isn\u2019t a rewrite. It\u2019s a recognition of reality, followed by a methodical simplification.", marks:[] }
      ]},
      { _type:'block', _key:'p31b', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p31b.0', text:"First, the thing that matters most: ", marks:[] },
        { _type:'span', _key:'p31b.1', text:"zero public API impact.", marks:['strong'] },
        { _type:'span', _key:'p31b.2', text:" PTE exports zero Slate types today. No consumer ever imports from ", marks:[] },
        { _type:'span', _key:'p31b.3', text:"slate", marks:['code'] },
        { _type:'span', _key:'p31b.4', text:" or ", marks:[] },
        { _type:'span', _key:'p31b.5', text:"slate-react", marks:['code'] },
        { _type:'span', _key:'p31b.6', text:". This is purely an internal restructuring \u2014 the public surface doesn\u2019t change at all.", marks:[] }
      ]},
      { _type:'block', _key:'p32', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p32.0', text:"Step 1: Vendor the source.", marks:['strong'] },
        { _type:'span', _key:'p32.1', text:" Copy ", marks:[] },
        { _type:'span', _key:'p32.2', text:"slate", marks:['code'] },
        { _type:'span', _key:'p32.3', text:", ", marks:[] },
        { _type:'span', _key:'p32.4', text:"slate-dom", marks:['code'] },
        { _type:'span', _key:'p32.5', text:", and ", marks:[] },
        { _type:'span', _key:'p32.6', text:"slate-react", marks:['code'] },
        { _type:'span', _key:'p32.7', text:" into the PTE monorepo as internal packages. Remove the external npm dependencies. Strip the 78% of Slate\u2019s API surface we don\u2019t use. All existing tests pass \u2014 behavioral equivalence verified. And we fix a real production headache: we don\u2019t control how Slate declares ", marks:[] },
        { _type:'span', _key:'p32.8', text:"slate-dom", marks:['code'] },
        { _type:'span', _key:'p32.9', text:" as a peer dependency, which means Canvas \u2014 which depends on PTE both directly and through Sanity \u2014 ends up pulling in ", marks:[] },
        { _type:'span', _key:'p32.10', text:"slate-dom", marks:['code'] },
        { _type:'span', _key:'p32.11', text:" multiple times. Duplicate copies, bundle bloat, subtle bugs. Vendoring eliminates this entire class of dependency-graph problems.", marks:[] }
      ]},
      { _type:'block', _key:'p33', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p33.0', text:"Step 2: Progressively unify.", marks:['strong'] },
        { _type:'span', _key:'p33.1', text:" With the code in-house, we can start collapsing the translation layer piece by piece. Eliminate the dual-model sync \u2014 make Slate\u2019s tree ", marks:[] },
        { _type:'span', _key:'p33.2', text:"be", marks:['em'] },
        { _type:'span', _key:'p33.3', text:" the PT tree. Merge the render pipeline so PTE\u2019s multi-callback dispatch is first-class, not a layer on top. Unify normalization into a single pass. Merge the two Editable components (PTE\u2019s 27KB wrapper + Slate\u2019s 76KB = 103KB today; target ~45\u201350KB unified). Each change is a focused PR with clear before/after.", marks:[] }
      ]},
      { _type:'block', _key:'p34', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p34.0', text:"Step 1 is low-risk and immediately beneficial \u2014 we stop depending on an external package with no active steward and we can strip dead code. Step 2 is where the real gains compound: fewer bugs, an estimated ", marks:[] },
        { _type:'span', _key:'p34.1', text:"60\u201370% reduction in per-keystroke overhead", marks:['strong'] },
        { _type:'span', _key:'p34.2', text:" by eliminating boundary crossings and translation, simpler debugging, and a clear path to containers.", marks:[] }
      ]},
      { _type:'block', _key:'p35', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p35.0', text:"The total codebase should ", marks:[] },
        { _type:'span', _key:'p35.1', text:"shrink", marks:['em'] },
        { _type:'span', _key:'p35.2', text:", not grow. We\u2019re not adding Slate\u2019s 328KB on top of our 493KB \u2014 we\u2019re collapsing both into something smaller and more coherent than either.", marks:[] }
      ]},

      // === What we keep ===
      { _type:'block', _key:'h2g', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2g.0', text:"What we keep", marks:[] }
      ]},
      { _type:'block', _key:'p36', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p36.0', text:"Let\u2019s be clear about what we\u2019re preserving. Slate\u2019s core value \u2014 the hard-won ", marks:[] },
        { _type:'span', _key:'p36.1', text:"contenteditable", marks:['code'] },
        { _type:'span', _key:'p36.2', text:" handling, DOM reconciliation, selection management, input handling, IME composition, mobile keyboard support \u2014 all of it stays. This is battle-tested code across browsers and edge cases. We\u2019re not rewriting it. We\u2019re owning it.", marks:[] }
      ]},
      { _type:'block', _key:'p37', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p37.0', text:"What we\u2019re removing is the translation layer between Slate and PTE. The dual-model sync. The patch conversion. The render dispatch indirection. The double normalization pass. The 96 code paths that exist only because two systems need to agree on what the document looks like.", marks:[] }
      ]},

      // === The bottom line ===
      { _type:'block', _key:'h2h', style:'h2', markDefs:[], children:[
        { _type:'span', _key:'h2h.0', text:"The bottom line", marks:[] }
      ]},
      { _type:'block', _key:'p38', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p38.0', text:"PTE has already built a parallel editor runtime. We maintain 493KB of translation code to bridge between our system and a 328KB framework we\u2019ve mostly outgrown. That bridge costs us roughly one bug per week, 40\u201350 extra function calls per keystroke, and 106KB of tests that exist solely to verify the translation doesn\u2019t drift.", marks:[] }
      ]},
      { _type:'block', _key:'p39', style:'normal', markDefs:[
        { _key:'hl3', _type:'highlight' }
      ], children:[
        { _type:'span', _key:'p39.0', text:"", marks:['hl3'] },
        { _type:'span', _key:'p39.1', text:"We\u2019re not leaving Slate because it\u2019s bad. We\u2019re leaving because we\u2019ve already left.", marks:['hl3'] }
      ]},
      { _type:'block', _key:'p40', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p40.0', text:"The question isn\u2019t whether to own the editor \u2014 it\u2019s whether to keep pretending we don\u2019t.", marks:[] }
      ]},
      { _type:'block', _key:'p41', style:'normal', markDefs:[], children:[
        { _type:'span', _key:'p41.0', text:"It\u2019s time to make it official.", marks:['em'] }
      ]},
    ];

    // ===== STATE =====
    let dark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    let selectedKey = null;
    let mobileTab = 'rendered'; // 'source' | 'rendered' — default to article on mobile

    // ===== HELPERS =====
    function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // ===== PT RENDERERS =====
    function renderSpan(span, markDefs) {
      let t = esc(span.text); if (!t) return '';
      const defs = markDefs || [];
      for (const m of (span.marks||[])) {
        if (m==='strong') t=`<strong>${t}</strong>`;
        else if (m==='em') t=`<em>${t}</em>`;
        else if (m==='code') t=`<code>${t}</code>`;
        else if (m==='underline') t=`<u>${t}</u>`;
        else if (m==='strikethrough') t=`<s>${t}</s>`;
        else {
          // Check markDefs for annotations
          const def = defs.find(d => d._key === m);
          if (def && def._type === 'highlight') {
            t = `<mark class="hl">${t}</mark>`;
          } else if (def && def._type === 'link') {
            t = `<a href="${esc(def.href)}" class="lnk" target="_blank" rel="noopener">${t}</a>`;
          }
        }
      }
      return t;
    }

    function renderBlock(b) {
      if (b._type === 'factBox') {
        const cl = `fb${selectedKey===b._key?' sel':''}`;
        return `<div class="${cl}" data-key="${b._key}" data-fb="1">
          <div class="fb-num">${esc(b.number)}</div>
          <div class="fb-label">${esc(b.label)}</div>
          <div class="fb-meta">{ _type: 'factBox' }</div>
        </div>`;
      }
      const inner = (b.children||[]).map(s => renderSpan(s, b.markDefs)).join('');
      const s = b.style||'normal';
      const cl = `ptb${selectedKey===b._key?' sel':''}`;
      const a = `class="${cl}" data-key="${b._key}"`;
      if (s==='h1') return `<h1 ${a}>${inner}</h1>`;
      if (s==='h2') return `<h2 ${a}>${inner}</h2>`;
      if (s==='h3') return `<h3 ${a}>${inner}</h3>`;
      if (s==='blockquote') return `<blockquote ${a}>${inner}</blockquote>`;
      return `<p ${a}>${inner}</p>`;
    }

    function renderArticle() { return PT.map(renderBlock).join('\n'); }

    // ===== JSON HIGHLIGHTER =====
    function hj(obj, ind) {
      const p = '  '.repeat(ind), p1 = '  '.repeat(ind+1);
      if (obj===null) return `<span class="jb">null</span>`;
      if (typeof obj==='boolean') return `<span class="jb">${obj}</span>`;
      if (typeof obj==='number') return `<span class="jn">${obj}</span>`;
      if (typeof obj==='string') {
        const e = esc(obj).replace(/"/g,'&quot;');
        return `<span class="js">"${e}"</span>`;
      }
      if (Array.isArray(obj)) {
        if (!obj.length) return `<span class="jbr">[]</span>`;
        if (obj.length<=4 && obj.every(v=>typeof v==='string'||typeof v==='number')) {
          const items = obj.map(v=>hj(v,ind)).join(`<span class="jbr">, </span>`);
          return `<span class="jbr">[</span>${items}<span class="jbr">]</span>`;
        }
        const items = obj.map(v=>`${p1}${hj(v,ind+1)}`).join(',\n');
        return `<span class="jbr">[</span>\n${items}\n${p}<span class="jbr">]</span>`;
      }
      if (typeof obj==='object') {
        const keys = Object.keys(obj);
        if (!keys.length) return `<span class="jbr">{}</span>`;
        const entries = keys.map(k => {
          const v = hj(obj[k],ind+1);
          let kc = 'jk';
          if (k==='_type') kc='jt';
          else if (k==='marks'||k==='markDefs') kc='jm';
          return `${p1}<span class="${kc}">"${esc(k)}"</span><span class="jbr">: </span>${v}`;
        }).join(',\n');
        return `<span class="jbr">{</span>\n${entries}\n${p}<span class="jbr">}</span>`;
      }
      return String(obj);
    }

    function renderJSON() {
      const blocks = PT.map((b,i) => {
        const json = hj(b,1);
        const cl = `jblk${selectedKey===b._key?' sel':''}`;
        return `<div class="${cl}" data-key="${b._key}">${json}${i<PT.length-1?',':''}</div>`;
      }).join('\n');
      return `<span class="jbr">[</span>\n${blocks}\n<span class="jbr">]</span>`;
    }

    // ===== STYLES =====
    function css() {
      const d = dark;
      return `
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,400&display=swap');
        * { margin:0; padding:0; box-sizing:border-box; }
        #ptv {
          width:100%; height:100%; display:flex; flex-direction:column;
          background:${d?'#0a0e14':'#fafaf5'};
          color:${d?'#b8c4d0':'#2e3440'};
          font-family:'JetBrains Mono',ui-monospace,'SF Mono',Menlo,Consolas,monospace;
          font-size:13px; line-height:1.6; overflow:hidden;
        }

        /* Header */
        .hdr {
          display:flex; align-items:center; justify-content:space-between;
          padding:0 16px; height:42px;
          border-bottom:1px solid ${d?'#1a2030':'#d4d4c8'};
          background:${d?'#0d1117':'#f0f0e8'}; flex-shrink:0;
        }
        .hdr-left { display:flex; align-items:center; gap:10px; }
        .hdr-title {
          font-size:12px; font-weight:500;
          color:${d?'#5c6b7f':'#6e7681'};
          letter-spacing:0.5px;
        }
        .hdr-title .cmd { color:${d?'#5ccfe6':'#0969da'}; }
        .hdr-title .flag { color:${d?'#c3a6ff':'#7c3aed'}; }
        .hdr-title .file { color:${d?'#bae67e':'#1a7f37'}; }
        .hdr-right { display:flex; align-items:center; gap:8px; }
        .hdr-badge {
          font-size:10px; font-weight:600;
          color:${d?'#5ccfe6':'#0969da'};
          letter-spacing:1px; text-transform:uppercase;
          padding:3px 8px; border-radius:4px;
          border:1px solid ${d?'rgba(92,207,230,0.3)':'rgba(9,105,218,0.3)'};
        }
        .toggle {
          width:30px; height:30px; border-radius:6px;
          border:1px solid ${d?'#1a2030':'#d4d4c8'};
          background:transparent; cursor:pointer; display:flex; align-items:center;
          justify-content:center; color:${d?'#5c6b7f':'#6e7681'}; font-size:15px;
          transition: background 0.15s, color 0.15s;
        }
        .toggle:hover { background:${d?'rgba(92,207,230,0.06)':'rgba(9,105,218,0.06)'}; color:${d?'#b8c4d0':'#2e3440'}; }

        /* Panels */
        .panels { display:flex; flex:1; overflow:hidden; }
        .panel {
          flex:1; overflow-y:auto; overflow-x:hidden;
          scrollbar-width:thin;
          scrollbar-color:${d?'rgba(92,107,127,0.2)':'rgba(0,0,0,0.1)'} transparent;
        }
        .panel::-webkit-scrollbar { width:5px; }
        .panel::-webkit-scrollbar-track { background:transparent; }
        .panel::-webkit-scrollbar-thumb { background:${d?'rgba(92,107,127,0.2)':'rgba(0,0,0,0.1)'}; border-radius:3px; }
        .divider {
          width:1px; background:${d?'#1a2030':'#d4d4c8'}; flex-shrink:0;
        }
        .plabel {
          font-size:10px; font-weight:600;
          color:${d?'#3d4f5f':'#9ca3af'};
          letter-spacing:2px; text-transform:uppercase;
          padding:12px 16px 6px; user-select:none;
        }
        .plabel::before { content:'// '; }

        /* JSON panel */
        .jp { background:${d?'#0d1117':'#fdfdfa'}; }
        .jc {
          padding:0 16px 24px; white-space:pre; tab-size:2;
          font-size:12px; line-height:1.7;
        }
        .jblk {
          padding:3px 6px; margin:0 -6px; border-radius:3px; cursor:pointer;
          border:1px solid transparent; transition: background 0.12s, border-color 0.12s;
          display:block;
        }
        .jblk:hover { background:${d?'rgba(92,207,230,0.04)':'rgba(9,105,218,0.04)'}; }
        .jblk.sel {
          background:${d?'rgba(92,207,230,0.1)':'rgba(9,105,218,0.12)'};
          border-color:${d?'rgba(92,207,230,0.25)':'rgba(9,105,218,0.25)'};
          border-left:3px solid ${d?'#5ccfe6':'#0969da'};
        }
        .jk { color:${d?'#5ccfe6':'#0550ae'}; }
        .js { color:${d?'#bae67e':'#0a3069'}; }
        .jn { color:${d?'#ffcc66':'#953800'}; }
        .jb { color:${d?'#ff8f40':'#cf222e'}; }
        .jbr { color:${d?'#3d4f5f':'#8b949e'}; }
        .jt { color:${d?'#c3a6ff':'#8250df'}; }
        .jm { color:${d?'#ff8f40':'#953800'}; }

        /* Render panel */
        .rp { background:${d?'#0a0e14':'#fafaf5'}; }
        .rc { padding:0 28px 32px; max-width:660px; }
        .rc h1 {
          font-size:22px; font-weight:800; color:${d?'#e8edf4':'#1a1e26'};
          line-height:1.25; margin:18px 0 10px; letter-spacing:-0.03em;
        }
        .rc h2 {
          font-size:14px; font-weight:700; color:${d?'#e8edf4':'#1a1e26'};
          line-height:1.35; margin:32px 0 8px; letter-spacing:0.02em;
          text-transform:uppercase; letter-spacing:1px;
          padding-bottom:6px;
          border-bottom:1px solid ${d?'#1a2030':'#d4d4c8'};
        }
        .rc h2::before { content:'## '; color:${d?'#3d4f5f':'#9ca3af'}; }
        .rc p {
          font-size:13px; line-height:1.8; color:${d?'#b8c4d0':'#3b4252'};
          margin:0 0 18px; font-weight:300;
        }
        .rc strong { color:${d?'#e8edf4':'#1a1e26'}; font-weight:600; }
        .rc em { color:${d?'#c3a6ff':'#7c3aed'}; font-style:italic; }
        .rc code {
          font-size:0.88em; padding:1px 5px; border-radius:3px;
          background:${d?'#151d28':'#eeeee6'};
          color:${d?'#e5c07b':'#b45309'};
          border:1px solid ${d?'#1a2030':'#d4d4c8'};
        }
        .rc mark.hl {
          background:${d?'rgba(92,207,230,0.12)':'rgba(9,105,218,0.1)'};
          color:${d?'#5ccfe6':'#0550ae'};
          padding:1px 3px; border-radius:2px;
          border-bottom:2px solid ${d?'rgba(92,207,230,0.4)':'rgba(9,105,218,0.35)'};
        }
        .rc a.lnk {
          color:${d?'#5ccfe6':'#0969da'};
          text-decoration:underline;
          text-decoration-color:${d?'rgba(92,207,230,0.35)':'rgba(9,105,218,0.35)'};
          text-underline-offset:2px;
          transition:text-decoration-color 0.15s;
        }
        .rc a.lnk:hover {
          text-decoration-color:${d?'#5ccfe6':'#0969da'};
        }
        .ptb {
          padding:4px 8px; margin:0 -8px; border-radius:3px; cursor:pointer;
          border:1px solid transparent; transition: background 0.12s, border-color 0.12s;
        }
        .ptb:hover { background:${d?'rgba(92,207,230,0.04)':'rgba(9,105,218,0.04)'}; }
        .ptb.sel {
          background:${d?'rgba(92,207,230,0.1)':'rgba(9,105,218,0.12)'};
          border-color:${d?'rgba(92,207,230,0.25)':'rgba(9,105,218,0.25)'};
          border-left:3px solid ${d?'#5ccfe6':'#0969da'};
        }

        /* Fact boxes */
        .fb {
          margin:16px 0; padding:14px 16px; border-radius:4px; cursor:pointer;
          border:1px solid ${d?'#1a2030':'#d4d4c8'};
          background:${d?'#0d1117':'#ffffff'};
          border-left:3px solid ${d?'#5ccfe6':'#0969da'};
          transition: background 0.12s, border-color 0.12s;
          position:relative;
        }
        .fb:hover {
          background:${d?'rgba(92,207,230,0.04)':'rgba(9,105,218,0.04)'};
        }
        .fb.sel {
          background:${d?'rgba(92,207,230,0.07)':'rgba(9,105,218,0.06)'};
          border-color:${d?'rgba(92,207,230,0.3)':'rgba(9,105,218,0.3)'};
          border-left-color:${d?'#5ccfe6':'#0969da'};
        }
        .fb-num {
          font-size:26px; font-weight:800; letter-spacing:-0.02em;
          color:${d?'#5ccfe6':'#0969da'};
          margin-bottom:2px;
        }
        .fb-label {
          font-size:12px; font-weight:400; line-height:1.5;
          color:${d?'#7a8a9e':'#57606a'};
        }
        .fb-meta {
          position:absolute; top:8px; right:10px;
          font-size:10px; font-weight:400;
          color:${d?'#283040':'#c0c0b4'};
          opacity:0; transition: opacity 0.3s 0.15s;
          pointer-events:none;
        }
        .fb:hover .fb-meta { opacity:1; }

        /* Tab bar (mobile only) */
        .tabs {
          display:none; flex-shrink:0;
          border-bottom:1px solid ${d?'#1a2030':'#d4d4c8'};
          background:${d?'#0d1117':'#f0f0e8'};
        }
        .tab {
          flex:1; padding:10px 0; text-align:center; cursor:pointer;
          font-size:11px; font-weight:600; letter-spacing:1.5px; text-transform:uppercase;
          color:${d?'#5c6b7f':'#8b949e'}; background:transparent;
          border:none; border-bottom:2px solid transparent;
          font-family:inherit; transition: color 0.15s, border-color 0.15s;
          -webkit-tap-highlight-color:transparent;
          min-height:44px;
        }
        .tab:active { background:${d?'rgba(92,207,230,0.04)':'rgba(9,105,218,0.04)'}; }
        .tab.active {
          color:${d?'#5ccfe6':'#0969da'};
          border-bottom-color:${d?'#5ccfe6':'#0969da'};
        }

        /* Responsive */
        @media (max-width:700px) {
          .tabs { display:flex; }
          .hdr-title { font-size:11px; }
          .hdr-title .flag, .hdr-title .file { display:none; }
          .hdr-badge { display:none; }
          .divider { display:none; }
          .plabel { display:none; }
          .panels { flex-direction:column; }
          .panel { flex:none; height:100%; }
          .panel.hidden { display:none; }
          .jp { overflow-x:auto; -webkit-overflow-scrolling:touch; }
          .jc { font-size:11px; padding:8px 12px 24px; overflow-x:auto; min-width:max-content; }
          .rc { padding:0 16px 32px; }
          .rc h1 { font-size:19px; margin:14px 0 8px; }
          .rc h2 { font-size:12px; margin:24px 0 6px; }
          .rc p { font-size:12px; line-height:1.75; margin:0 0 12px; }
          .rc code { font-size:0.85em; }
          .fb { margin:14px 0; padding:16px; }
          .fb-num { font-size:22px; margin-bottom:4px; }
          .fb-label { font-size:12px; line-height:1.6; }
          .fb-meta { opacity:0.5; font-size:9px; }
          .ptb { padding:10px 10px; margin:0 -10px; min-height:44px; }
          .jblk { padding:6px 8px; margin:0 -8px; min-height:44px; }
        }
      `;
    }

    // ===== DOM =====
    const root = document.createElement('div');
    root.id = 'ptv';
    container.appendChild(root);

    function build() {
      root.innerHTML = `
        <style>${css()}</style>
        <div class="hdr">
          <div class="hdr-left">
            <div class="hdr-title"><span class="cmd">$</span> pte-grows-up <span class="flag">--render</span> <span class="file">article.pt.json</span></div>
          </div>
          <div class="hdr-right">
            <div class="hdr-badge">${PT.length} blocks</div>
            <button class="toggle" id="thm" title="Toggle theme">${dark?'\u2600\uFE0E':'\u263E'}</button>
          </div>
        </div>
        <div class="tabs" id="tabs">
          <button class="tab${mobileTab==='source'?' active':''}" data-tab="source">// source</button>
          <button class="tab${mobileTab==='rendered'?' active':''}" data-tab="rendered">// rendered</button>
        </div>
        <div class="panels">
          <div class="panel jp${mobileTab!=='source'?' hidden':''}" id="jp">
            <div class="plabel">source</div>
            <div class="jc" id="jc">${renderJSON()}</div>
          </div>
          <div class="divider"></div>
          <div class="panel rp${mobileTab!=='rendered'?' hidden':''}" id="rp">
            <div class="plabel">rendered</div>
            <div class="rc" id="rc">${renderArticle()}</div>
          </div>
        </div>
      `;
      wire();
    }

    function wire() {
      root.querySelector('#thm').addEventListener('click', () => { dark=!dark; build(); });
      root.querySelectorAll('.tab').forEach(el => el.addEventListener('click', () => {
        mobileTab = el.dataset.tab;
        root.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab===mobileTab));
        const jp = root.querySelector('#jp'), rp = root.querySelector('#rp');
        if (jp) jp.classList.toggle('hidden', mobileTab!=='source');
        if (rp) rp.classList.toggle('hidden', mobileTab!=='rendered');
      }));
      root.querySelectorAll('.jblk').forEach(el => el.addEventListener('click', () => select(el.dataset.key, 'json')));
      root.querySelectorAll('.ptb').forEach(el => el.addEventListener('click', () => select(el.dataset.key, 'rendered')));
      root.querySelectorAll('.fb').forEach(el => el.addEventListener('click', () => select(el.dataset.key, 'rendered')));
    }

    function scrollPanelTo(el) {
      const panel = el.closest('.panel');
      if (!panel || panel.classList.contains('hidden')) return;
      const panelRect = panel.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      const target = panel.scrollTop + (elRect.top - panelRect.top) - (panelRect.height / 2) + (elRect.height / 2);
      panel.scrollTo({ top: Math.max(0, target), behavior: 'smooth' });
    }

    function select(key, source) {
      selectedKey = selectedKey===key ? null : key;
      root.querySelectorAll('.jblk').forEach(el => el.classList.toggle('sel', el.dataset.key===selectedKey));
      root.querySelectorAll('.ptb').forEach(el => el.classList.toggle('sel', el.dataset.key===selectedKey));
      root.querySelectorAll('.fb').forEach(el => el.classList.toggle('sel', el.dataset.key===selectedKey));
      if (selectedKey) {
        // Only scroll the OTHER panel — the one the user didn't click in
        if (source !== 'json') {
          const je = root.querySelector('.jblk.sel');
          if (je) scrollPanelTo(je);
        }
        if (source !== 'rendered') {
          const re = root.querySelector('.ptb.sel, .fb.sel');
          if (re) scrollPanelTo(re);
        }
      }
    }

    build();
  },
  cleanup() {}
};
artifact.render(document.getElementById('app'), {
  width: window.innerWidth,
  height: window.innerHeight
});
</script>
</body>
</html>
